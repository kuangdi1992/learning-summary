# 事件处理

## 介绍

与界面编程紧密相关的就是事件处理了，当用户在程序界面执行各种操作时，应用程序需要为用户动作提供响应动作，这种响应动作需要通过事件处理来完成。

Android提供了两种方式的事件处理：

> 基于回调的事件处理：主要做法是重写Android组件特定的回调方法，或重写Activity的回调方法
>
> 基于监听器的事件处理：主要做法是为Android界面组件绑定特定的事件监听器。（android为绝大部分界面组件提供了事件响应的回调方法，开发者只需要重写它们）

## 基于监听的事件处理

### 事件监听的处理模型

在事件监听的处理模型中，主要涉及如下三类对象：

> Event Source（事件源）：事件发生的场所，通常是各个组件，例如按钮、窗口、菜单等
>
> Event（事件）：事件封装了界面组件上发生的特定事情（通常就是一次用户操作）。如果程序需要获取界面组件上所发生事件的相关信息，一般通过Event对象来获取。
>
> Event Listener（事件监听器）：负责监听事件源所发生的事件，并对各种事件做出相应的响应。

当用户按下一个按钮或者单击某个菜单项时，这些动作就会激发一个相应的事件，该事件会触发事件源上注册的事件监听器，事件监听器调用对应的事件处理器来做出相应的响应。

Android的事件处理机制是一种委派式事件处理方式：事件源将整个事件处理委托给特定的对象（事件监听器），当该事件源发生指定的事件时，通知所委托的事件监听器，由事件监听器来处理这个事件。

每个组件均可以针对特定的事件指定一个事件监听器，每个事件监听器也可以监听一个或多个事件源。因为同一个事件源上可能发生多种事件，委派式事件处理方式可以把事件源上所有可能发生的事件分别授权给不同的事件监听器来处理，同时也可以让一类事件都使用同一个事件监听器来处理。

![24](F:\git资料\Learning-summary\Picture\Android\24.png)

## 实例

实现一个简单的基于监听的时间处理模型的程序。

界面上有两个组件：一个文本框、一个按钮。定义的按钮为事件源，并为按钮绑定一个事件监听器。

activity_main.xml:

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:gravity="center_horizontal"
    android:orientation="vertical">

    <EditText
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/text"
        android:editable="true"
        android:cursorVisible="true"
        android:textSize="12px"/>
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/bt"
        android:text="ShapeDemo"/>
</LinearLayout>
```

MainActivity.java

```Java
public class MainActivity extends Activity implements View.OnClickListener {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.bt);
        //为按钮绑定事件监听器
        button.setOnClickListener(this);
    }

    @Override
    public void onClick(View view) {
        EditText text = (EditText) findViewById(R.id.text);
        text.setText("bn被单击了！");
    }
}
或者
public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.bt);
        //为按钮绑定事件监听器
        button.setOnClickListener(new MyClickListener());
    }

    class MyClickListener implements View.OnClickListener{
        @Override
        public void onClick(View view) {
            EditText text = (EditText) findViewById(R.id.text);
            text.setText("bn被单击了！");
        }
    }

}
```

结果：

![25](https://github.com/kuangdi1992/learning-summary/blob/master/Picture/Android/25.png)

上面的代码先为bn按钮注册事件监听器，当程序中的按钮被单击时，处理器被触发，文本框内变成被单击了。

## 步骤

1. 获取普通界面组件，被监听的对象
2. 实现事件监听器类，该监听器类是一个特殊的Java类，必须实现一个XXXListener接口
3. 调用事件源的setXXXListener方法将事件监听器对象注册给普通组件