# 约束（非常重要）

## 介绍

约束：constraint

数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。

在创建表的时候，可以给表中的字段加上约束来保证表中数据的完整性，有效性。

为了保证数据的完整性，SQL规范以约束的方式对表数据进行额外的条件限制。从以下四个方面考虑：

- 实体完整性（Entity Integrity） ：例如，同一个表中，不能存在两条完全相同无法区分的记录 
- 域完整性（Domain Integrity） ：例如：年龄范围0-120，性别范围“男/女” 
- 引用完整性（Referential Integrity） ：例如：员工所在部门，在部门表中要能找到这个部门 
- 用户自定义完整性（User-defined Integrity） ：例如：用户名唯一、密码不能为空等，本部门 经理的工资不得高于本部门职工的平均工资的5倍

约束是表级的强制规定，可以在创建表时规定约束（CREATE TABLE）或在创建表之后通过ALTER TABLE规定约束。

## 约束分类

- 根据约束数据列的限制，约束可分为：
  - 单列约束：每个约束只约束一列 
  - 多列约束：每个约束可约束多列数据 
- 根据约束的作用范围，约束可分为：
  - 列级约束：只能作用在一个列上，<font color=red>跟在列的定义后面 </font>
  - 表级约束：可以作用在多个列上，不与列一起，而是<font color=red>单独定义</font>
- 根据约束起的作用，约束可分为： 
  - NOT NULL 非空约束，规定某个字段不能为空 
  - UNIQUE 唯一约束，规定某个字段在整个表中是唯一的 
  - PRIMARY KEY 主键(非空且唯一)约束
  - FOREIGN KEY 外键约束 
  - CHECK 检查约束 
  - DEFAULT 默认值约束

## 常见约束

### 非空约束not null

非空约束not null约束的字段不能为NULL。

只有列级约束。

### 示例

```sql
mysql> create table t_vip(id int,name varchar(255) not null);
Query OK, 0 rows affected (0.25 sec)

mysql> desc t_vip;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id    | int          | YES  |     | NULL    |       |
| name  | varchar(255) | NO   |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
2 rows in set (0.04 sec)
mysql> insert into t_vip(id,name) values(1,'kd');
Query OK, 1 row affected (0.04 sec)

mysql> insert into t_vip(id,name) values(2,'hl');
Query OK, 1 row affected (0.04 sec)

mysql> insert into t_vip(id) values(2);
1364 - Field 'name' doesn't have a default value
```

可以看到name没有默认值，表示不能为空。

### 唯一性约束unique

唯一性约束unique约束的字段不能重复，但是可以为NULL。

#### 示例1 列级约束

```sql
mysql>  create table t_vip(id int,name varchar(255) unique,email varchar(255));
Query OK, 0 rows affected (0.65 sec)

mysql> insert into t_vip(id,name,email) values(1,'kd','kd@123.com');
Query OK, 1 row affected (0.08 sec)

mysql> select * from t_vip;
+----+------+------------+
| id | name | email      |
+----+------+------------+
|  1 | kd   | kd@123.com |
+----+------+------------+
1 row in set (0.03 sec)

mysql> insert into t_vip(id,name,email) values(2,'kd','kd@123.com');
1062 - Duplicate entry 'kd' for key 't_vip.name'

mysql> insert into t_vip(id) values(2);
Query OK, 1 row affected (0.07 sec)

mysql> select * from t_vip;
+----+------+------------+
| id | name | email      |
+----+------+------------+
|  1 | kd   | kd@123.com |
|  2 | NULL | NULL       |
+----+------+------------+
2 rows in set (0.03 sec)

```

可以看出，name字段被unique约束，不能重复，一旦重复后会出现如下报错：

```sql
1062 - Duplicate entry 'kd' for key 't_vip.name'
```

但是，name字段可以为NULL，而NULL可以重复。

#### 示例2 表级约束

需求：name和email两个字段联合起来具有唯一性

```sql
mysql>  create table t_vip(
			id int,
			name varchar(255),
			email varchar(255),
			unique(name,email)
            CONSTRAINT bk_test2_email UNIQUE(email)//约束名);			
Query OK, 0 rows affected (0.32 sec)

mysql> desc t_vip;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id    | int          | YES  |     | NULL    |       |
| name  | varchar(255) | YES  | MUL | NULL    |       |
| email | varchar(255) | YES  |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
3 rows in set (0.03 sec)

mysql> insert into t_vip(id,name,email) values
(1,'kd','kd@123.com');
Query OK, 1 row affected (0.05 sec)

mysql> insert into t_vip(id,name,email) values
(2,'kd','kd1@123.com');
Query OK, 1 row affected (0.04 sec)

mysql> insert into t_vip(id,name,email) values
(3,'kd1','kd@123.com');
Query OK, 1 row affected (0.03 sec)

mysql> insert into t_vip(id,name,email) values(4,'kd','kd@123.com');
1062 - Duplicate entry 'kd-kd@123.com' for key 't_vip.name'
```

从上面的示例中，可以看出两个字段联合的唯一性约束中，两个字段可以分别不同，<font color=red>只有两个字段完全一样的时候才会报错</font>。

### 主键约束（primary key，简称pk）

<font color=red>主键字段：添加了主键约束的字段。一个表中最多只能有一个主键约束。</font>

主键值：主键字段中的每一个值，每一行记录的唯一标识。

任何一张表都应该有主键。

主键值一般都是定长的，使用int,bigint,char等，不建议使用varchar。

#### 特征

主键值不能为NULL，也不能重复（not null + unique）。

##### 列级约束写法—单一主键

```sql
mysql> drop table if exists t_vip;
Query OK, 0 rows affected (0.23 sec)

mysql> create table t_vip(
    	id int primary key,
   		new varchar(255));
Query OK, 0 rows affected (0.25 sec)

mysql> insert into t_vip(id, new) values(1,'kd');
Query OK, 1 row affected (0.08 sec)

mysql> insert into t_vip(id, new) values(2,'kd1');
Query OK, 1 row affected (0.06 sec)

mysql> insert into t_vip(id, new) values(2,'kd2');
1062 - Duplicate entry '2' for key 't_vip.PRIMARY'
mysql> insert into t_vip(new) values('kd2');
1364 - Field 'id' doesn't have a default value
mysql> select * from t_vip;
+----+-----+
| id | new |
+----+-----+
|  1 | kd  |
|  2 | kd1 |
+----+-----+
2 rows in set (0.02 sec)
```

从上面的代码中可以看出，主键值不能为空，也不能重复，不然会报错。

##### 表级约束写法

主要给多个字段联合起来添加约束（复合主键：两个及以上的字段做主键）—<font color=red>使用较少</font>。

```sql
mysql> create table t_vip(
    	id int,
    	new varchar(255),
    	primary key(id));
Query OK, 0 rows affected (0.45 sec)

mysql>  insert into t_vip(id, new) values(1,'kd');
Query OK, 1 row affected (0.05 sec)

mysql> insert into t_vip(id, new) values(1,'kd2');
1062 - Duplicate entry '1' for key 't_vip.PRIMARY'
```

##### 建表后增加主键约束

```sql
ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多 个字段的话，是复合主键
```

```sql
CREATE TABLE test4 (
id INT,
last_name VARCHAR(15),
salary DECIMAL(10,2)
);

ALTER TABLE test4
ADD PRIMARY KEY(id);

DESC test4;
```

![image-20230312193233076](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20230312193233076.png)

##### 多列复合主键

如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。

```sql
create table 表名称(    
	字段名  数据类型,    
	字段名  数据类型,      
	字段名  数据类型,    
	primary key(字段名1,字段名2)  #表示字段1和字段2的组合是唯一的，也可以有更多个字段 
);
```

```sql
CREATE TABLE test3 (
	id INT,
	last_name VARCHAR(15),
	salary DECIMAL(10,2),
	email VARCHAR(25),
	passwd VARCHAR(25),
	PRIMARY KEY(last_name,passwd)
);

SELECT * FROM information_schema.TABLE_CONSTRAINTS
WHERE table_name = 'test3';

INSERT INTO test3(id,last_name,salary,email,passwd)
VALUES(1,'she','4300','kd@126.com','123456');

SELECT * FROM test3;

INSERT INTO test3(id,last_name,salary,email,passwd)
VALUES(1,'she','4300','kd@126.com','23456');

INSERT INTO test3(id,last_name,salary,email,passwd)
VALUES(1,NULL,'4300','kd@126.com','123456');
> 1048 - Column 'last_name' cannot be null
> 时间: 0s
```

##### 删除主键约束

```sql
alter table 表名称 drop primary key;
```

```sql
ALTER TABLE test4 DROP PRIMARY KEY;
```

删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。

![image-20230312194214133](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20230312194214133.png)

#### 自然主键

主键值是一个自然数，在实际开发中用的多，只要不重复就行，不需要有意义。

##### 特点和要求

（1）一个表最多只能有一个自增长列
（2）当需要产生唯一标识符或顺序值时，可设置自增长
（3）自增长列约束的列必须是键列（主键列，唯一键列）
（4）自增约束的列的数据类型必须是整数类型
（5）如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接 赋值为具体值

#### 业务主键

主键值和业务紧密关联，例如用银行卡账号做主键。

当业务发生变动时，可能影响主键值。

#### 自动维护主键方法

自增主键：

在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重 置AUTO_INCREMENT=max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。 下面通过案例来对比不同的版本中自增变量是否持久化。出现上述结果的主 要原因是自增主键没有持久化。 在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典 内部一个 计数器 来决定的，而该计数器只在 内存中维护 ，并不会持久化到磁盘中。当数据库重启时，该 计数器会被初始化。 

MySQL 8.0将自增主键的计数器持久化到 **重做日志** 中。每次计数器发生改变，都会将其写入重做日志 中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。

```sql
create table t_vip(
	id int primary key auto_increment,
	name varchar(255)
);
#建表时
create table 表名称(
    字段名  数据类型  primary key auto_increment,
    字段名  数据类型  unique key not null,
    字段名  数据类型  unique key,
    字段名  数据类型  not null default 默认值,
); 

create table 表名称(
    字段名  数据类型 default 默认值 ,    
    字段名  数据类型 unique key auto_increment,
    字段名  数据类型 not null default 默认值,
    primary key(字段名)
);

#建表后
alter table 表名称 modify 字段名 数据类型 auto_increment;

create table employee(
    eid int primary key ,
    ename varchar(20)
);

alter table employee modify eid int auto_increment;

mysql> desc employee; 
+-------+-------------+------+-----+---------+----------------+ 
| Field | Type        | Null | Key | Default | Extra          |
+-------+-------------+------+-----+---------+----------------+
| eid   | int(11)     | NO   | PRI | NULL    | auto_increment | 
| ename | varchar(20) | YES  |     | NULL    |                |
+-------+-------------+------+-----+---------+----------------+
2 rows in set (0.00 sec)

```

在创建表的时候，使用auto_increment（自增，类型为int，bigint）即可。

当向主键的字段上添加0或null时，实际上会自动往上添加指定的值。

##### 删除自增约束

```sql
#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束
alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除
alter table employee modify eid int;
```



### 外键约束（foreign key，简称fk）

#### 术语

外键字段：添加了外键约束的字段。

外键值：外键字段中的每一个值。

 MySQL 外键约束（FOREIGN KEY）是表的一个特殊字段，经常与主键约束一起使用。对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表（父表），<font color=red>外键所在的表就是从表（子表）</font>>。

外键用来建立主表与从表的关联关系，为两个表的数据建立连接，约束两个表中数据的一致性和完整性。比如，一个水果摊，只有苹果、桃子、李子、西瓜等 4 种水果，那么，你来到水果摊要买水果就只能选择苹果、桃子、李子和西瓜，其它的水果都是不能购买的。

主表删除某条记录时，从表中与之对应的记录也必须有相应的改变。一个表可以有一个或多个外键，外键可以为空值，若不为空值，则每一个外键的值必须等于主表中主键的某个值。

定义外键时，需要遵守下列规则：

- 主表必须已经存在于数据库中，或者是当前正在创建的表。如果是后一种情况，则主表与从表是同一个表，这样的表称为自参照表，这种结构称为自参照完整性。
- 必须为主表定义主键。
- 主键不能包含空值，但允许在外键中出现空值。也就是说，只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的。
- 在主表的表名后面指定列名或列名的组合。这个列或列的组合必须是主表的主键或候选键。
- 外键中列的数目必须和主表的主键中列的数目相同。
- 外键中列的数据类型必须和主表主键中对应列的数据类型相同。
- 删除表：先删除子表，后删除父表
- 创建表：先创建父表，后创建子表
- 删除数据：先删除子表中的数据，再删除父表中的数据
- 插入数据：先插入父表中，再插入子表中

#### 示例一

业务背景：

设计数据库表，来描述“班级和学生”的信息。

第一种方案：班级和学生存储在一张表中

```sql
t_student
no(pk)         name         classno         classname
1              jack         101             一班
2              lili         101             一班
3              lilei        102             二班
4              zhangsan     102             二班
```

上面的方案会造成数据冗余，空间浪费。

第二种方案：一张班级表，一张学生表

```sql
t_class 班级表
classno(pk)     classname
101             一班
102             二班
t_student 学生表
no(pk)          name              cno(班级编号，FK——引用t_class表的classno)
1               jack              101
2               lili              101
3               lilei             102
4               zhangsan          102
```

对于上面学生表中的班级编号字段，需要有约束来让班级编号和班级表中的主键classno联系起来，让班级编号只能取classno中的值（101和102）。

这里cno有外键约束，cno字段为具有外键约束的字段。

代码：

创建t_class和t_student表

```sql
mysql> create table t_class(classno int primary key,classname varchar(255));
Query OK, 0 rows affected (0.27 sec)

mysql> create table t_student(
    no int primary key auto_increment,
    name varchar(255),
    cno int,
    foreign key(cno) references t_class(classno)//外键约束
);
Query OK, 0 rows affected (0.42 sec)

mysql> desc t_student;
+-------+--------------+------+-----+---------+----------------+
| Field | Type         | Null | Key | Default | Extra          |
+-------+--------------+------+-----+---------+----------------+
| no    | int          | NO   | PRI | NULL    | auto_increment |
| name  | varchar(255) | YES  |     | NULL    |                |
| cno   | int          | YES  | MUL | NULL    |                |
+-------+--------------+------+-----+---------+----------------+
3 rows in set (0.03 sec)

```

插入数据

```sql
mysql> insert into t_class(classno,classname) values(101,'一班');
Query OK, 1 row affected (0.05 sec)

mysql> insert into t_class(classno,classname) values(102,'二班');
Query OK, 1 row affected (0.07 sec)

mysql> select * from t_class;
+---------+-----------+
| classno | classname |
+---------+-----------+
|     101 | 一班      |
|     102 | 二班      |
+---------+-----------+
2 rows in set (0.04 sec)

mysql> insert into t_student(name,cno) values('jack',101);
Query OK, 1 row affected (0.08 sec)

mysql> insert into t_student(name,cno) values('lili',101);
Query OK, 1 row affected (0.04 sec)

mysql> insert into t_student(name,cno) values('lilei',102);
Query OK, 1 row affected (0.04 sec)

mysql> insert into t_student(name,cno) values('zhangsan',102);
Query OK, 1 row affected (0.04 sec)

mysql> select * from t_student;
+----+----------+-----+
| no | name     | cno |
+----+----------+-----+
|  1 | jack     | 101 |
|  2 | lili     | 101 |
|  3 | lilei    | 102 |
|  4 | zhangsan | 102 |
+----+----------+-----+
4 rows in set (0.03 sec)
```

然后查看t_student表中相关外键可以取到的值，如下图所示：

![image-20211014211632078](https://github.com/kuangdi1992/Interview-knowledge/blob/master/Picture/MySQL/image-20211014211632078.png)

只有t_class主键classno中的两个值可以取。

#### 示例二

```sql
#创建主表
CREATE TABLE dept(
	dept_id INT,
	dept_name VARCHAR(15)
);


#创建从表
CREATE TABLE emp(
	emp_id INT PRIMARY KEY AUTO_INCREMENT,
	emp_name VARCHAR(15),
	department_id INT,
	CONSTRAINT fk_emp_dept_id FOREIGN KEY(department_id) REFERENCES dept(dept_id)
);
#1822 - Failed to add the foreign key constraint. Missing index for constraint 'fk_emp_dept_id' in the referenced table 'dept'
#主表添加主键约束或唯一性约束
ALTER TABLE dept
ADD PRIMARY KEY (dept_id);

DESC emp;

#演示外键效果
INSERT INTO emp
VALUES(1001,'tOM',10);
#1452 - Cannot add or update a child row: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `fk_emp_dept_id` FOREIGN KEY (`department_id`) REFERENCES `dept` (`dept_id`))
INSERT INTO dept
VALUES(10,'tOM');

SELECT * from emp;

#删除失败
DELETE FROM dept
where dept_id = 10;
#1451 - Cannot delete or update a parent row: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `fk_emp_dept_id` FOREIGN KEY (`department_id`) REFERENCES `dept` (`dept_id`))

#更新失败
UPDATE dept
SET dept_id = 20
WHERE dept_id = 10;
#1451 - Cannot delete or update a parent row: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `fk_emp_dept_id` FOREIGN KEY (`department_id`) REFERENCES `dept` (`dept_id`))

```

#### 约束等级

- Cascade方式 ：在父表上update/delete记录时，同步update/delete掉子表的匹配记录 

- Set null方式 ：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子 表的外键列不能为not null 

- No action方式 ：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作 

- Restrict方式 ：同no action， 都是立即检查外键约束 

- Set default方式 （在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置 成一个默认的值，但Innodb不能识别
  如果没有指定等级，就相当于Restrict方式
- 对于外键约束，最好是采用: ON UPDATE CASCADE ON DELETE RESTRICT 的方式。

#### 删除外键约束

流程如下：

```sql
(1)第一步先查看约束名和删除外键约束 
SELECT * FROM information_schema.table_constraints WHERE table_name = '表名称';#查看某个 表的约束名
ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;

（2）第二步查看索引名和删除索引。（注意，只能手动删除） 
SHOW INDEX FROM 表名称; #查看某个表的索引名
ALTER TABLE 从表名 DROP INDEX 索引名;
```

示例：

```sql
mysql> SELECT * FROM information_schema.table_constraints WHERE table_name = 'emp';
mysql> alter table emp drop foreign key emp_ibfk_1; 
Query OK, 0 rows affected (0.02 sec) Records: 0  Duplicates: 0  Warnings: 0
mysql> show index from emp;
mysql> alter table emp drop index deptid;
Query OK, 0 rows affected (0.01 sec) Records: 0  Duplicates: 0  Warnings: 0
```

#### 阿里开发规范

【 强制 】不得使用外键与级联，一切外键概念必须在应用层解决。
说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学 生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于 单 机低并发 ，不适合 分布式 、 高并发集群 ；级联更新是强阻塞，存在数据库 更新风暴 的风险；外键影响 数据库的 插入速度 

### 检查约束

check（mysql5没有，mysql8.0支持，Oracle有）

##### 作用

检查某个字段的值是否符号xx要求，一般指的是值的范围

```sql
CREATE TABLE test1(
	id INT,
	last_name VARCHAR(15),
	salary DECIMAL(10,2) CHECK(salary > 2000)
);

DESC test1;

INSERT INTO test1
VALUES(1,'kd',25000);

INSERT INTO test1
VALUES(1,'kd',1000);
#3819 - Check constraint 'test1_chk_1' is violated.
```

### DEFAULT约束 

#### 作用 

给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默 认值

#### CREATE TABLE添加

```sql
create table 表名称(
字段名  数据类型  primary key,
字段名  数据类型  unique key not null,
字段名  数据类型  unique key,
字段名  数据类型  not null default 默认值
);
说明：默认值约束一般不在唯一键和主键列上加
```

```sql
create table employee(
eid int primary key,
ename varchar(20) not null,
gender char default '男',
tel char(11) not null default '' #默认是空字符串 
);
```

#### 建表后修改

```sql
alter table 表名称 modify 字段名 数据类型 default 默认值;
#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被 删除了 
#同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默 认值约束，否则就删除了 
alter table 表名称 modify 字段名 数据类型 default 默认值 not null;
```

```sql
alter table employee modify gender char default '男';  #给gender字段增加默认值约束 
alter table employee modify tel char(11) default ''; #给tel字段增加默认值约束
```

## not null和unique联合

```sql
lmysql> create table t_vip(
    	id int,
    	name varchar(255) not null unique);
Query OK, 0 rows affected (0.26 sec)

mysql> desc t_vip;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id    | int          | YES  |     | NULL    |       |
| name  | varchar(255) | NO   | PRI | NULL    |       |
+-------+--------------+------+-----+---------+-------+
2 rows in set (0.03 sec)
```

可以看出，name是not null 和unique联合约束后，name变成了主键primary key。（注意：Oracle中不一样！）