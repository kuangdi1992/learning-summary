# 为什么使用索引

索引是存储引擎用于快速找到数据记录的一种数据结构。进行数据查找时，首先查看查询条件是否命中某条索引，符合则可以通过索引查找相关数据，如果不符合则要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。

![image-20230516082804768](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20230516082804768.png)

假如给数据使用`二叉树`进行存储，如下图所示：

![image-20230516202620556](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20230516202620556.png)

对字段Col2添加了索引，相当于在硬盘上为Col2维护了一个索引的数据结构，`二叉搜索树`。二叉搜索树的每个结点存储的是`(K,V)结构`，key是Col2，value是该key所在行的文件指针。例如：该二叉搜索树的根节点是（34,0x07）。现在对Col2添加了索引，这时候查询Col2=89这条记录的时候会先查找该二叉搜索树，读34到内存，`89>34`，继续查找右侧数据，读89到内存，`89 == 89`，找到数据。

目的：`减少磁盘IO的次数，加快查询速率。`

# 索引及优缺点

## 概述

MySQL官方对索引的定义为：`索引（Index）是帮助MySQL高效获取数据的数据结构。`

索引的本质：`索引是数据结构`。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 高级查找算法 。

## 优点

（1）类似大学图书馆建书目索引，`提高数据检索的效率，降低数据库的IO成本` ，这也是创建索引最主要的原因。

（2）通过创建`唯一索引`，可以`保证数据库表中每一行数据的唯一性` 。

（3）在`实现数据的参考完整性方面`，可以`加速表和表之间的连接` 。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。

（4）在`使用分组和排序子句进行数据查询`时，可以`显著减少查询中分组和排序的时间 ，降低了CPU的消耗`。

## 缺点

增加索引也有许多不利的方面，主要表现在如下几个方面： 

​	（1）`创建索引和维护索引要耗费时间 `，并且随着数据量的增加，所耗费的时间也会增加。 

​	（2）`索引需要占磁盘空间 ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间`， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。 

​	（3）`虽然索引大大提高了查询速度，同时却会降低更新表的速度 。`当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。

# InnoDB中索引推演

## 索引之前的查找

### 在一个页中查找

- 以主键为搜索条件

  可以在页目录中使用`二分法`快速定位到对应的槽，然后遍历该槽对应分钟中的记录可快速找到指定的记录。

- 以其他列为搜索条件

  在数据页中没有对非主键列建立页目录，因此无法用二分法快速定位相应的槽，只能从最小记录开始依次遍历单链表中的每条记录。
  

### 在很多页中查找

在大部分情况下，表中存放的记录是非常多的，需要很多数据页才能存储。在很多数据页中查找记录可以分为两个步骤：

- 定位到记录所在的页
- 在所在页中查找相应的记录

在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从`第一个页沿着双向链表一直往下找`，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是很耗时的。如果一个表有一亿条记录呢？此时索引应运而生。

## 设计索引

### 示例

#### 建表

```sql
mysql> CREATE TABLE index_demo(
    -> c1 INT,
    -> c2 INT,
    -> c3 CHAR(1),
    -> PRIMARY KEY(c1)
    -> ) ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.57 sec)

mysql> desc index_demo;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| c1    | int     | NO   | PRI | NULL    |       |
| c2    | int     | YES  |     | NULL    |       |
| c3    | char(1) | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```

![image-20230516210601343](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20230516210601343.png)

- record_type ： 记录头信息的一项属性，表示记录的类型， 0 表示普通记录、1表示目录项记录、 2 表示最小记录、 3 表示最大记录。
- next_record ： 记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。
- 各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。
- 其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

效果如下：

![image-20230516212450697](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20230516212450697.png)

将记录放到页里的示意图如下：

![image-20230516210534714](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20230516210534714.png)