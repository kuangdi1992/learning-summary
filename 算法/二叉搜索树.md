# 二叉搜索树

## 介绍

二叉搜索树——Binary Search Tree，BST。

### 定义

二叉搜索树是一种节点值之间具有一定数量级次序的二叉树，对于树中每个节点：

- 若其左子树存在，则其左子树中每个节点的值都不大于该节点值；
- 若其右子树存在，则其右子树中每个节点的值都不小于该节点值。

### 查询复杂度

观察二叉搜索树结构可知，查询每一个节点需要的比较次数为节点深度加一。在二叉搜索树节点个数确定的情况下，整棵树的高度越低，节点的查询复杂度越低。

### 构造复杂度

二叉搜索树的构造过程，也就是**将节点不断插入到树中适当位置的过程**。该操作过程，与查询节点元素的操作基本相同，不同之处在于：

- 查询节点过程是，比较元素值是否相等，相等则返回，不相等则判断大小情况，迭代查询左、右子树，直到找到相等的元素，或子节点为空，返回节点不存在
- 插入节点的过程是，比较元素值是否相等，相等则返回，表示已存在，不相等则判断大小情况，迭代查询左、右子树，直到找到相等的元素，或子节点为空，则将节点插入该空节点位置。

由此可知，单个节点的构造复杂度和查询复杂度相同，为 ![O(log_2 n)](https://math.jianshu.com/math?formula=O(log_2%20n))~![O(n)](https://math.jianshu.com/math?formula=O(n))。

### 性能分析

由以上查询复杂度、构造复杂度和删除复杂度的分析可知，三种操作的时间复杂度皆为 ![O(log_2 n)](https://math.jianshu.com/math?formula=O(log_2%20n))~![O(n)](https://math.jianshu.com/math?formula=O(n))。下面分析线性结构的三种操作复杂度，以二分法为例：

- 查询复杂度，时间复杂度为 ![O(log_2 n)](https://math.jianshu.com/math?formula=O(log_2%20n))，优于二叉搜索树；
- 元素的插入操作包括两个步骤，查询和插入。查询的复杂度已知，插入后调整元素位置的复杂度为 ![O(n)](https://math.jianshu.com/math?formula=O(n))，即单个元素的构造复杂度为：![O(n)](https://math.jianshu.com/math?formula=O(n))
- 删除操作也包括两个步骤，查询和删除，查询的复杂度已知，删除后调整元素位置的复杂度为 ![O(n)](https://math.jianshu.com/math?formula=O(n))，即单个元素的删除复杂度为：![O(n)](https://math.jianshu.com/math?formula=O(n))

由此可知，二叉搜索树相对于线性结构，在构造复杂度和删除复杂度方面占优；在查询复杂度方面，二叉搜索树可能存在类似于斜树，每层上只有一个节点的情况，该情况下查询复杂度不占优势。

## 做题分析

直接基于BST的数据结构有AVL树，红黑树等，有自平衡性质，可以提供logN级别的增删改查效率。

B+树，线段树等结构是基于BST的思想设计的。

#### 思考角度

**BST的中序遍历结果是升序的。**

如果输入一棵 BST，以下代码可以将 BST 中每个节点的值升序打印出来：

```java
void traverse(TreeNode root) {
    if (root == null) return;
    traverse(root.left);
    // 中序遍历代码位置
    print(root.val);
    traverse(root.right);
}
```

**BST 中任意一个节点的左子树所有节点的值都小于该节点的值，右子树所有节点的值都大于该节点的值。**

并且BST中任一节点的左右子树都是BST。

BST 的这种特性可以<u>在二叉树中做类似二分搜索的操作</u>，搜索一个元素的效率很高。

伪代码如下：

```java
void BST(TreeNode root, int target) {
    if (root.val == target)
        // 找到目标
    if (root.val < target) 
        BST(root.right, target);
    if (root.val > target)
        BST(root.left, target);
}
```

#### 算法实践（BST的中序遍历结果是升序的）

#### 寻找第k小的元素（leetcode 230）

#### 题目

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

#### 示例

![img](https://github.com/kuangdi1992/Interview-knowledge/blob/master/Picture/Leetcode/kthtree1.jpg)

```java
输入：root = [3,1,4,null,2], k = 1
输出：1
```

#### 分析

从题目和示例可以看出，需要找出二叉搜索树的第k个最小的元素。

根据上面的特征：BST的中序遍历是升序的。可以思考到使用BST的中序遍历来解决这个问题。

#### 代码

```java
class Solution {
    int rank = 0;
    int result = 0;
    public int kthSmallest(TreeNode root, int k) {
        middletrave(root,k);
        return result;
    }

    public void middletrave(TreeNode root,int k){
        if(root == null){
            return;
        }

        middletrave(root.left,k);
        //中序遍历中间代码
        rank++;
        if(rank == k){
            result = root.val;
            return;
        }


        middletrave(root.right,k);
    }
}
```

#### 把二叉搜索树转化成累加树（leetcode 538）

#### 题目

给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

​	节点的左子树仅包含键 小于 节点键的节点。
​	节点的右子树仅包含键 大于 节点键的节点。
​	左右子树也必须是二叉搜索树。

#### 示例

![img](https://github.com/kuangdi1992/Interview-knowledge/blob/master/Picture/Leetcode/tree.png)

```
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```

#### 分析

第一步：理解题目，比如图中的节点 5，转化成累加树的话，比 5 大的节点有 6，7，8，加上 5 本身，所以累加树上这个节点的值应该是 5+6+7+8=26。

第二步：从二叉搜索树的通用思路出发，二叉搜索树的中序遍历是升序的，也就是将二叉搜索树进行中序遍历，可以升序打印节点值，但是这道题目需要找出大于或者等于当前节点的节点进行累加，所以降序打印节点，并进行累加。

第三步：当到当前节点时累加值就是累加树中该节点的节点值。

#### 代码

```java
class Solution {
    int result = 0;
    public TreeNode convertBST(TreeNode root) {
        traverse(root);
        return root;
    }
    public void traverse(TreeNode root){
        if(root == null){
            return;
        }

        traverse(root.right);

        result += root.val;
        
        root.val = result;

        traverse(root.left);
    }
}
```

这道题就解决了，核心还是 BST 的中序遍历特性，只不过我们修改了递归顺序，降序遍历 BST 的元素值，从而契合题目累加树的要求。

#### 算法实践（ BST 左小右大的特性）

#### 验证BST合法性

