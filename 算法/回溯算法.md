# 回溯算法

## 介绍

回溯算法实际上是常说的DFS算法，本质上是一种暴力穷举算法。

解决一个回溯问题，实际上是一个决策树的遍历过程。

思考3个问题：

1、路径：已经做出的选择

2、选择列表：当前可以做出的选择

3、结束条件：到达决策树底层，无法再做出选择的条件。

基本框架：

```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

上述代码的核心是for循环中的递归，在递归调用之前做出选择，在递归调用之后撤销选择。

## 全排列问题

### 说明

全排列问题n个不重复的数，全排列的个数有n！个。

例如：给出三个数[1,2,3]，可以将它的全排列穷举出来，其中可以画出一个回溯树如下：

![image-20211027222844594](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20211027222844594.png)

只要从根开始遍历这棵树，记录路径上的数字，就是所有的全排列——那么这棵树就是回溯算法的决策树。

因为在每个节点都做了决策，比如站在下图中红色的节点上：

![image-20211027223033983](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20211027223033983.png)

现在就可以做出决策，选择1号或者选择3号。

那么，2就是路径，记录已经做过的选择，[1,3]就是选择列表，当前可以做出的选择，结束条件就是遍历到树底层。

![image-20211027223214155](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20211027223214155.png)

可以将路径和选择列表作为决策树上每个节点的属性，那么定义的backtrack函数像一个指针，在决策树上走动，并正确维护每个节点的属性，当走到底层时，路径就是一个全排列。

因为函数在决策树上走动时需要维护每个节点的属性，其中属性为路径和选择列表，那么以根节点为例，当走路径1时，需要从选择列表中移除1，然后在路径上加上1（做选择的过程），当递归backtrack函数执行完后，需要将1从路径中删除，然后将1加入到选择列表中（撤销选择的过程），这样就可以进行下一次路径2的遍历。

所以核心框架如下：

```
for 选择 in 选择列表:
    # 做选择
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表)
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表
```

因此**只要在递归之前做出选择，在递归之后撤销刚才的选择**，就能正确得到每个节点的选择列表和路径。

代码：

```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    public List<List<Integer>> permute(int[] nums) {
        LinkedList<Integer> track = new LinkedList<>();
        backtrack(nums,track);
        return res;

    }
    public void backtrack(int[] nums, LinkedList<Integer> track){
        /*track 路径
          nums 选择列表
          结束条件：路径和nums的长度一致*/
        if(track.size() == nums.length){
            res.add(new LinkedList(track));
            return;
        }

        for(int i = 0; i < nums.length; i++){
            if(!track.contains(nums[i])){
                track.add(nums[i]); //将nums[i]加入到路径中
                backtrack(nums,track);
                track.removeLast(); //从路径中移除最后一个
            }
        }
    }
}
```

**回溯算法就是纯暴力穷举，复杂度一般都很高**。

## N皇后问题

