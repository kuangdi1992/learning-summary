# 前缀和算法

## 介绍

前缀和：数组该位置之前的元素之和。例如:[1,1,1,1],则前缀和数组为0,1,2,3,4(这里需要第一个元素为0)。

思路：

对于一个给定的数组nums，使用额外开辟一个前缀和数组preSum进行预处理：

```java
int n = nums.length;
// 前缀和数组
int[] preSum = new int[n + 1];
preSum[0] = 0;
for (int i = 0; i < n; i++)
    preSum[i + 1] = preSum[i] + nums[i];
```

通过前缀和，想要求nums[i...j]的和，只需要一步操作：preSum[j+1] - preSum[i]即可。

## 题目（Leetcode 560）

给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。

示例 1：

```
输入：nums = [1,1,1], k = 2
输出：2
```


示例 2：

```
输入：nums = [1,2,3], k = 3
输出：2
```

思路1：前缀和

```java
int subarraySum(int[] nums, int k) {
    int n = nums.length;
    // 构造前缀和
    int[] sum = new int[n + 1];
    sum[0] = 0; 
    for (int i = 0; i < n; i++)
        sum[i + 1] = sum[i] + nums[i];
    
    int ans = 0;
    // 穷举所有子数组
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < i; j++)
            // sum of nums[j..i-1]
            if (sum[i] - sum[j] == k)
                ans++;

    return ans;
}
```

时间复杂度：O(N*N)

空间复杂度：O(N)

对于这个前缀和方法来说，时间复杂度过于大了。

优化：

主要是时间复杂度消耗在两个for循环中，在计算**有几个 `j` 能够使得 `sum[i]` 和 `sum[j]` 的差为 k**。毎找到一个这样的 `j`，就把结果加一。

那么，如果直接记录下有几个sum[j]和sum[i] - k相等，直接更新结果，就避免了内层的for循环。

这里就用到了hash表。

代码如下：

```java
public int subarraySum(int[] nums, int k) {
        int length = nums.length;
        Map<Integer,Integer> presum = new HashMap<>();

        presum.put(0,1);

        int ans = 0;
        int sum_i = 0;
        for(int i = 0; i < length; i++){
            sum_i += nums[i];
            int sum_j = sum_i - k;
            if(presum.containsKey(sum_j)){
                ans += presum.get(sum_j);
            }
            presum.put(sum_i, presum.getOrDefault(sum_i, 0) + 1);
        }
        return ans;
    }
```

对于hash表的用法，在另一章中讲解。

那么在这里时间复杂度就成了O(N)了。