# 前缀和算法

适用于：快速、频繁地计算一个索引区间内的元素之和。

**前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和**。

## 介绍

前缀和：数组该位置之前的元素之和。例如:[1,1,1,1],则前缀和数组为0,1,2,3,4(这里需要第一个元素为0)。

思路：

对于一个给定的数组nums，使用额外开辟一个前缀和数组preSum进行预处理：

```java
int n = nums.length;
// 前缀和数组
int[] preSum = new int[n + 1];
preSum[0] = 0;
for (int i = 0; i < n; i++)
    preSum[i + 1] = preSum[i] + nums[i];
```

通过前缀和，想要求nums[i...j]的和，只需要一步操作：preSum[j+1] - preSum[i]即可。

## 题目

### 和为k的子数组 Leetcode 560

给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。

示例 1：

```
输入：nums = [1,1,1], k = 2
输出：2
```


示例 2：

```
输入：nums = [1,2,3], k = 3
输出：2
```

思路1：前缀和

```java
int subarraySum(int[] nums, int k) {
    int n = nums.length;
    // 构造前缀和
    int[] sum = new int[n + 1];
    sum[0] = 0; 
    for (int i = 0; i < n; i++)
        sum[i + 1] = sum[i] + nums[i];
    
    int ans = 0;
    // 穷举所有子数组
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < i; j++)
            // sum of nums[j..i-1]
            if (sum[i] - sum[j] == k)
                ans++;

    return ans;
}
```

时间复杂度：O(N*N)

空间复杂度：O(N)

对于这个前缀和方法来说，时间复杂度过于大了。

优化：

主要是时间复杂度消耗在两个for循环中，在计算**有几个 `j` 能够使得 `sum[i]` 和 `sum[j]` 的差为 k**。毎找到一个这样的 `j`，就把结果加一。

那么，如果直接记录下有几个sum[j]和sum[i] - k相等，直接更新结果，就避免了内层的for循环。

这里就用到了hash表。

代码如下：

```java
public int subarraySum(int[] nums, int k) {
        int length = nums.length;
        Map<Integer,Integer> presum = new HashMap<>();

        presum.put(0,1);

        int ans = 0;
        int sum_i = 0;
        for(int i = 0; i < length; i++){
            sum_i += nums[i];
            int sum_j = sum_i - k;
            if(presum.containsKey(sum_j)){
                ans += presum.get(sum_j);
            }
            presum.put(sum_i, presum.getOrDefault(sum_i, 0) + 1);
        }
        return ans;
    }
```

对于hash表的用法，在另一章中讲解。

那么在这里时间复杂度就成了O(N)了。

###  二维区域和检索 - 矩阵不可变 leetcode304

#### 题目

给定一个二维矩阵 matrix，以下类型的多个请求：

计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。
实现 NumMatrix 类：

NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化
int sumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1, col1) 、右下角 (row2, col2) 所描述的子矩阵的元素 总和 。

#### 示例

![img](F:\git资料\Learning-summary\Picture\Leetcode\1626332422-wUpUHT-image.png)

```java
输入: 
["NumMatrix","sumRegion","sumRegion","sumRegion"]
[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]
输出: 
[null, 8, 11, 12]

解释:
NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)
numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)
numMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)
```

#### 分析

这道题的思路和一维数组的思路是相似的。

![image-20211118222117302](F:\git资料\Learning-summary\Picture\Leetcode\image-20211118222117302.png)

计算红色的这个子矩阵的元素之和，可以**用绿色矩阵减去蓝色矩阵减去橙色矩阵最后加上粉色矩阵**，而绿蓝橙粉这四个矩阵有一个共同的特点，就是左上角就是 `(0, 0)` 原点。

可以维护一个二维 `preSum` 数组，专门记录以原点为顶点的矩阵的元素之和，就可以用几次加减运算算出任何一个子矩阵的元素和：

#### 代码

```java
class NumMatrix {
    private int[][] preSum;
    public NumMatrix(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;

        if(m == 0 || n == 0){
            return;
        }

        preSum = new int[m+1][n+1];
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                preSum[i][j] = matrix[i-1][j-1] + preSum[i-1][j] + preSum[i][j-1] - preSum[i-1][j-1];
            }
        }


    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        int result = preSum[row2+1][col2+1] - preSum[row1][col2+1] - preSum[row2+1][col1] + preSum[row1][col1];
        return result;

    }
}
```

