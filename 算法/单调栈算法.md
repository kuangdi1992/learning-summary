# 单调栈算法

## 介绍

单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。

单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element。

## 模板

给你一个数组 `nums`，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。

比如说，输入一个数组 `nums = [2,1,2,4,3]`，返回数组 `[4,2,4,-1,-1]`。

解释：第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1。

代码模板：

```java
public int[] nextGreaterElement(int[] nums){
	int[] result = new int[nums.length];//存放结果的数组
	Stack<Integer> stack = new Stack<>();
	//将数组的值倒着往栈中放
	for(int i = nums.length - 1; i >= 0; i--){
		while(!stack.isEmpty() && stack.peek() <= nums[i]){ //如果栈顶元素小于当前元素，则栈顶元素可以直接丢弃
			stack.pop();
		}
		result[i] = stack.isEmpty() ? -1 : stack.peek();
		stack.push(nums[i]);
	}
	return result;
}
    
```

从整体来看：总共有 `n` 个元素，每个元素都被 `push` 入栈了一次，而最多会被 `pop` 一次，没有任何冗余操作。所以总的计算规模是和元素规模 `n` 成正比的，也就是 `O(n)` 的复杂度。

## 相关题目（相关的代码后续整理）

[496.下一个更大元素I（简单）](https://leetcode-cn.com/problems/next-greater-element-i)

[503.下一个更大元素II（中等）](https://leetcode-cn.com/problems/next-greater-element-ii)

[739.每日温度（中等）](https://leetcode-cn.com/problems/daily-temperatures/)

