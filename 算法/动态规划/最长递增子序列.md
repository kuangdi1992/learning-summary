# 最长递增子序列

## 题目（leetcode 300）

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```java
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

### 分析过程

#### 数学归纳法

想证明一个数学结论，先假设这个结论在k<n时成立，然后根据这个假设推导证明出k=n时成立。

我们在推导动态规划状态转移方程时，可以使用数学归纳法的思想：假设dp[0……i-1]都已经被计算出来了，怎样通过这些结果计算出dp[i]？

#### 状态转移方程

**定义dp的含义**：dp[i]表示以nums[i]这个数结尾的最长递增子序列的长度。

**base case**：dp[i]初始值为1，因为nums[i]结尾的最长递增子序列起码要包含它自己。根据这个定义，最终的结果是dp数组中的最大值。

```java
int res = 0;
for (int i = 0; i < dp.length; i++) {
    res = Math.max(res, dp[i]);
}
return res;
```

根据上面对dp数组的定义，现在想求dp[5]的值，就是求以nums[5]为结尾的最长递增子序列。

假设nums[5]=3，既然是递增子序列，只要找到前面那些结尾小于3的子序列，然后把3接到最后，就形成了一个新的递增子序列，而且这个新的子序列长度加一。

可能形成多种新的子序列，那么我们只需要最长的那一个。

```java
for (int j = 0; j < i; j++) {
    if (nums[i] > nums[j]) 
        dp[i] = Math.max(dp[i], dp[j] + 1);
}
```

类推出来，代码如下：

```java
for (int i = 0; i < nums.length; i++) {
    for (int j = 0; j < i; j++) {
        if (nums[i] > nums[j]) 
            dp[i] = Math.max(dp[i], dp[j] + 1);
    }
}
```

上面的代码中，就包含了所需要的状态转移方程。

### 总结

1、明确 `dp` 数组的定义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。

2、根据 `dp` 数组的定义，运用数学归纳法的思想，假设 `dp[0...i-1]` 都已知，想办法求出 `dp[i]`，一旦这一步完成，整个题目基本就解决了。

但如果无法完成这一步，很可能就是 `dp` 数组的定义不够恰当，需要重新定义 `dp` 数组的含义；或者可能是 `dp` 数组存储的信息还不够，不足以推出下一步的答案，需要把 `dp` 数组扩大成二维数组甚至三维数组。

### 代码

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp,1); //base case：dp数组中所有的初始化为1
        for(int i = 0; i < nums.length; i++){
            for(int j = 0; j < i; j++){
                if(nums[i] > nums[j]){
                    dp[i] = Math.max(dp[i],dp[j] + 1);
                }
            }
        }
        int res = 0;
        for(int i = 0; i < dp.length; i++){
            if(res < dp[i]){
                res = dp[i];
            }
        }
        return res;
    }
}
```



### 