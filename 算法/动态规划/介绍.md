# 动态规划

 首先，动态规划问题的一般形式就是求最值，比如最长递增子序列、最小编辑距离等等。

求解动态规划的核心问题是穷举。因为求最值，所以将所有可行的答案穷举出来，然后在其中找最值。

## 特点

1、动态规划这类问题存在<u>重叠子问题</u>。如果暴力法进行穷举的话效率就很低，需要用**备忘录或者DP table**来优化穷举过程，避免不必要的计算。

2、问题是千变万化的，穷举所有可行解需要列出正确的状态转移方程，才能正确穷举。

三要素：重叠子问题+最优子结构+正确的状态转移方程。

## 状态转移方程

明确base case ----> 明确状态 ---->明确选择---->定义dp数组/函数的含义

```c++
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)

```

### 示例

斐波拉契数列

- 递归解法

  ```java
  int fib(int N) {
      if (N == 1 || N == 2) return 1;
      return fib(N - 1) + fib(N - 2);
  }
  ```

  子问题个数：1+2+4+……+2^n-1为O(2^n)。

  时间复杂度为O(2^n)。

  发现了算法低效的原因：存在大量重复计算，比如 `f(18)` 被计算了两次，而且你可以看到，`f(18)`体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 `f(18)` 这一个节点被重复计算，所以这个算法及其低效。

  这里就有了第一个性质：重叠子问题。

- 带备忘录的递归解法

  每次计算出某个子问题的答案，先记录到备忘录中，每次遇到一个子问题先到备忘录中查找，如果发现之前解决过，就直接拿出答案。

  ```java
  int fib(int N) {
      // 备忘录全初始化为 0
      int[] memo = new int[N + 1];
      // 进行带备忘录的递归
      return helper(memo, N);
  }
  
  int helper(int[] memo, int n) {
      // base case
      if (n == 0 || n == 1) return n;
      // 已经计算过，不用再计算了
      if (memo[n] != 0) return memo[n];
      memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
      return memo[n];
  }
  ```

  时间复杂度O(N)。

  当然，我们可以从最底下进行推理，从问题规模最小的f(1)和f(2)开始推理，直到推到我们想要的答案，这就是动态规划的思路。

- dp数组的迭代解法

  ```java
  int fib(int N) {
      if (N == 0) return 0;
      int[] dp = new int[N + 1];
      // base case
      dp[0] = 0; dp[1] = 1;
      // 状态转移
      for (int i = 2; i <= N; i++) {
          dp[i] = dp[i - 1] + dp[i - 2];
      }
  
      return dp[N];
  }
  ```

  状态转移方程：

  ![img](F:\git资料\Learning-summary\Picture\Leetcode\fib.png)

  把f(n)想做一个状态n，这个状态n是由状态n-1和状态n-2相加转移而来的，这就是状态转移。

 