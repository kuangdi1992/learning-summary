# Redis单线程

## Redis为什么是单线程

Redis的版本很多，比如3.x、4.x、6.x等，版本不同，架构不同：

- 3.x版本，最早的版本，单线程
- 4.x版本，严格意义上来说不是单线程，负责处理客户端请求的线程是单线程，并且加了一些多线程（比如：异步删除）
- 2020年5月版本的6.0.x后及2022年出的7.0版本后，用一种全新的多线程来解决问题

## 介绍

Redis的单线程主要是指`Redis网络IO`和`键值对读写`是由一个线程来完成的，Redis在处理客户端的请求时包括`获取(Socket读)、解析、执行、内容返回(Socket写)`等都是由一个顺序串行的主线程处理，这时Redis对外提供键值对存储服务的主要流程。

![image-20230430194539696](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20230430194539696.png)

Redis其他功能，比如持久化RDB、AOF、异步删除、集群数据同步等，是由额外的线程执行的。

Redis命令的工作线程是单线程的，但是对于整个Redis来说，是多线程。

## Redis演进

### Redis 3.x 单线程时代性能很快的原因

- 基于内存操作
  - 所有Redis的数据都存在内存中，因此所有的运算都是内存级别的，所以他的性能高
- 数据结构简单
  - Redis的数据结构是专门设计的，这些简单的数据结构的查找和操作时间大部分复杂度都是O(1)，性能高
- 多路复用和非阻塞IO
  - Redis使用I/O多路复用功能来监听多个socket连接客户端，这样可以使用一个线程来处理多个请求，减少线程切换带来额开销，同时也避免了I/O阻塞操作
- 避免上下文切换
  - 因为是单线程模型，因此就避免了不必要的上下文切换和多线程竞争，这就省去了多线程切换带来的时间和性能上的消耗，而且单线程不会导致死锁问题的发生

### Redis4.0之前采用单线程的主要原因

> 使用单线程模型使Redis开发和维护更简单，单线程模型方便开发和调试
>
> 使用单线程模式也能并发处理多客户端的请求，主要使用IO多路复用和非阻塞IO
>
> 对于Redis来说，主要性能瓶颈是`内存和网络带宽`，不是CPU

### Redis单线程添加多线程特性的原因

单线程问题：要删除一个大key时，`del bigkey`会一直阻塞，等待删除完成，才能继续操作，会导致Redis主线程卡顿

解决方法：引入了`惰性删除`有效避免Redis主线程卡顿。

lazy free的本质就是把某些cost(主要时间复制度，占用主线程cpu时间片)较高删除操作，从redis主线程剥离让BIO子线程来处理，极大地减少主线阻塞时间。从而减少删除导致性能和稳定性问题。

虽然引入了多个线程来实现数据的异步惰性删除等功能，但其处理读写请求的仍然只有一个线程，所以仍然是狭义单线程。

# Redis6/7多线程

`Redis主要的性能瓶颈是内存和网络带宽，不是CPU`

## 真正意义的多线程

​	Redis一直被大家熟知的就是它的单线程架构，虽然有些命令操作可以用后台线程或子进程执行（比如数据删除、快照生成、AOF重写）。但是，从网络IO处理到实际的读写命令处理，都是由单个线程完成的。
​	`随着网络硬件的性能提升，Redis的性能瓶颈有时会出现在网络IO的处理上，也就是说，单个主线程处理网络请求的速度跟不上底层网络硬件的速度。`采用多个IO线程来处理网络请求，提高网络请求处理的并行度，Redis6/7就是采用的这种方法。
​	但是，`Redis的多IO线程只是用来处理网络请求的，对于读写操作命令Redis仍然使用单线程来处理`。这是因为，Redis处理请求时，网络处理经常是瓶颈，通过多个IO线程并行处理网络操作，可以提升实例的整体处理性能。而继续使用单线程执行命令操作，就不用为了保证Lua脚本、事务的原子性，额外开发多线程互斥加锁机制了(不管加锁操作处理)，这样一来，Redis线程模型实现就简单了。
​	Redis 只是将 I/O 读写变成了多线程，而命令的执行依旧是由主线程串行执行的。

## 主线程和IO线程的四个阶段

`阶段一`：服务端和客户端建立Socket连接，并分配处理线程

首先，主线程负责接收建立连接请求，当有客户端请求和实例建立Socket连接时，主线程会创建和客户端的连接，并把Socket放入全局等待队列中。紧接着，主线程通过轮询方法把Socket连接分配给IO线程。

`阶段二`：IO线程读取并解析请求

主线程一旦把Socket分配给IO线程，就会进入阻塞状态，等待IO线程完成客户端请求读取和解析。因为有多个IO线程在并行处理，所以该过程执行很快。

`阶段三`：主线程执行请求操作

等到IO线程解析完请求，主线程以单线程的方式执行命令操作。

`阶段四`：IO线程回写Socket和主线程清空全局队列

当主线程执行完请求操作后，把需要返回的结果写入缓冲区，然后主线程会阻塞等待IO线程，把这些结果回写到Socket中，并返回给客户端。和IO线程读取和解析请求一样，IO线程回写Socket时，有多个IO线程在并行处理，所以该过程执行很快，等到IO线程回写Socket完毕，主线程会清空全局队列，等待客户端的后续请求。

![image-20230430201806600](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20230430201806600.png)

![image-20230430202030913](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20230430202030913.png)

从Redis6开始，新增了多线程的功能来提高IO的读写性能，主要实现思路是将主线程的IO读写任务拆分给一组独立的线程去执行，这样就可以使用多个socket的读写进行并行化了，采用多路IO复用技术可以让单个线程高效处理多个连接请求，将最耗时的socket的读取、请求解析、写入等单独执行，剩下的命令执行仍然由主线程串行执行并和内存的数据交换。

![image-20230430202507515](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20230430202507515.png)

# 五种IO模型

## IO多路复用

一种同步的IO模型，实现一个线程监视多个文件句柄，一旦某个文件句柄就绪就能够通知到对应应用程序进行相应的读写操作，没有文件句柄就绪时就会阻塞应用程序，从而释放CPU资源。【响应式的】

IO：网络IO，尤其在操作系统中指数据在内核态和用户态之间的读写操作

多路：多个客户端连接（套接字描述符，Socket）

复用：复用一个或多个线程

**注意：套接字描述符是访问套接字的一种路径，套接字对唯一标识一个网络上的每个TCP连接。**

IO多路复用： 一个或一组线程处理多个TCP连接，使用单进程就能够实现同时处理多个客户端的连接，无需创建或者维护过多的进程/线程。

- 一个服务端进程可以同时处理多个套接字描述符
- 实现IO多路复用的模型有3种： select -> poll -> epoll 三个阶段

![image-20230430211141649](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20230430211141649.png)

**只使用一个服务端进程可以同时处理多个套接字描述符连接。**

![image-20230430211837859](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20230430211837859.png)

Redis快的原因：IO多路复用+epoll函数的使用。

# Redis7开启多线程

在单机模式下，可以开启多线程，但是在其他模式，最好不开启

Redis实例的 **CPU开销不大但吞吐量却没有提升**，可以考虑使用Redis7的多线程机制，加速网络处理，进而提升实例的吞吐量。

```shell
io-threads 4
io-threads-do-redis no
```

- 注意线程数
  - 官方的建议是如果为 4 核的 CPU，建议线程数设置为 2 或 3，如果为 8 核 CPU 建议线程数设置为 6，线程数一定要小于机器核数，线程数并不是越大越好。
- 设置io-thread-do-reads配置项为yes，表示启动多线程。