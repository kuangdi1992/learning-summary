### 内存映射

常说的内存容量是指物理内存，物理内存也称为主存。只有内核才可以直接访问物理内存。

问题：进程要访问内存时，要怎么办？

Linux内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的，这样进程可以很方便的访问虚拟内存。

虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同字长（也就是单个 CPU 指令可以处理数据的最大长度）的处理器，地址空间的范围也不同。比如最常见的 32 位和 64 位系统，两张图来分别表示它们的虚拟地址空间，如下所示：

![img](https://static001.geekbang.org/resource/image/ed/7b/ed8824c7a2e4020e2fdd2a104c70ab7b.png?wh=1004*456)

每个进程都分为用户态和内核态。进程在用户态时，只能访问用户空间内存，只有进入内核态之后，才能访问内核空间内存。每个进程的地址空间都包含了内核空间，但这些内核空间，关联的都是相同的物理内存。（进程用户态和内核态的切换？）

#### 问答

问题：每个进程都有自己的虚拟地址空间，那么所有进程的虚拟内存加起来比物理内存大很多，OS是怎么处理的？

答：不是所有的虚拟内存都会分配物理内存，只有那些实际使用的虚拟内存才分配物理内存，并且分配后的物理内存，是通过内存映射来管理的。

#### 详细解释

内存映射是将虚拟内存地址映射到物理内存地址。为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系，如下图所示：

![img](https://static001.geekbang.org/resource/image/fc/b6/fcfbe2f8eb7c6090d82bf93ecdc1f0b6.png?wh=572*370)

页表存储在CPU的内存管理单元MMU中，正常情况下，处理器可以直接通过硬件，找出要访问的内存。当进程访问的虚拟地址在页表中查找不到时，系统会产生一个缺页异常，进入内核空间分配物理内存、更新进程页表，最后返回用户空间，恢复进程的运行。

TLB 其实就是 MMU 中页表的高速缓存。由于进程的虚拟地址空间是独立的，而 TLB 的访问速度又比 MMU 快得多，所以，通过减少进程的上下文切换，减少 TLB 的刷新次数，就可以提高 TLB 缓存的使用率，进而提高 CPU 的内存访问性能。

MMU规定了一个内存映射的最小单位，页，通常大小4KB。这样，每次内存映射需要关联4KB或者4KB整数倍的内存空间。

> 页大小只有4KB会导致什么问题？
>
> 当页大小只有4KB的时候，整个页表会变得非常大，32位系统就需要100多万个页表项（4GB/4KB），才可以实现整个地址空间的映射。
>
> 为了解决页表项过多的问题，Linux提供了两种机制，多级页表和大页HugePage。

### 多级页表

多级页表将内存分成区块来管理，将原来的映射关系改成区块索引和区块内的偏移。

Linux用的是四级页表，如下：

![img](https://static001.geekbang.org/resource/image/b5/25/b5c9179ac64eb5c7ca26448065728325.png?wh=1390*460)

大页通常大小2MB和1GB，通常用在使用大量内存的进程上，如Oracle、DPDK等。

#### Linux进程中内存是怎么使用的？

### 内存的分配与回收

##### 分配

malloc函数是C标准库提供的内存分配函数，对应到系统调用上，有两种实现方式：brk()和mmap()。

对小块内存（小于 128K），C 标准库使用 brk() 来分配，也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用。

而大块内存（大于 128K），则直接使用内存映射 mmap() 来分配，也就是在文件映射段找一块空闲内存分配出去。

优缺点

brk() 方式的缓存，可以减少缺页异常的发生，提高内存访问效率。不过，由于这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片。

而 mmap() 方式分配的内存，会在释放时直接归还系统，所以每次 mmap 都会发生缺页异常。在内存工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大。这也是 malloc 只对大块内存使用 mmap 的原因。

但是，当这两种调用发生后，并没有真正分配内存。这些内存只在首次访问时才分配，即通过缺页异常进入内核中，再由内核来分配内存。

##### 回收

在应用程序用完内存后，还需要调用 free() 或 unmap() ，来释放这些不用的内存。

当然，系统也不会任由某个进程用完所有内存。在发现内存紧张时，系统就会通过一系列机制来回收内存，比如下面这三种方式：

> 回收缓存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面；
>
>  回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中；用到交换分区swap。Swap 其实就是把一块磁盘空间当成内存来用。它可以把进程暂时不用的数据存储到磁盘中（这个过程称为换出），当进程访问这些内存时，再从磁盘读取这些数据到内存中（这个过程称为换入）。【通常只有内存不足时，才会发生Swap交换，由于磁盘读写速度远比内存慢，Swap会导致严重的内存性能问题。】
>
> 杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程。

OOM是内核的一种保护机制，监控进程的内存使用情况，并且使用 oom_score 为每个进程的内存使用情况进行评分：

> 一个进程消耗的内存越大，oom_score 就越大；
>
> 一个进程运行占用的 CPU 越多，oom_score 就越小。

这样，进程的 oom_score 越大，代表消耗的内存越多，也就越容易被 OOM 杀死，从而可以更好保护系统。

为了实际工作的需要，管理员可以通过 /proc 文件系统，手动设置进程的 oom_adj ，从而调整进程的 oom_score。

oom_adj 的范围是 [-17, 15]，数值越大，表示进程越容易被 OOM 杀死；数值越小，表示进程越不容易被 OOM 杀死，其中 -17 表示禁止 OOM。

比如用下面的命令，你就可以把 sshd 进程的 oom_adj 调小为 -16，这样， sshd 进程就不容易被 OOM 杀死。

```shell
echo -16 > /proc/$(pidof sshd)/oom_adj
```

### 伙伴系统Slab

Linux通过伙伴系统来管理内存分配，以页为单位来管理内存，并且会通过相邻页的合并，来减少内存碎片化。

当实际系统运行时，会有大量比页小的对象，如果单独分配页，很浪费内存空间。

在用户空间中，malloc通过brk()分配的内存，在释放时不会立即归还系统，而是缓存起来重复利用，在内核空间，Linux通过slab分配器来管理小内存，slab是伙伴系统上的一个缓存，主要作用是分配和释放内核中的小对象。