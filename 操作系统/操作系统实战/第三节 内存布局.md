# 数据结构

需要获取内存布局信息，物理内存在物理地址空间是一段一段的，描述一段内存就需要有一个数据结构。

```c++
\cosmos-master\lesson12\Cosmos\initldr\include\ldrtype.h
#define RAM_USABLE 1 //可用内存
#define RAM_RESERV 2 //保留内存不可使用
#define RAM_ACPIREC 3 //ACPI表相关的
#define RAM_ACPINVS 4 //ACPI NVS空间
#define RAM_AREACON 5 //包含坏内存

typedef struct s_e820{
    u64_t saddr;    /* start of memory segment8内存开始地址 */
    u64_t lsize;    /* size of memory segment8内存大小 */
    u32_t type;    /* type of memory segment 4内存类型*/
}__attribute__((packed)) e820map_t;
```

获取内存布局信息，就是获取这个结构体的数组，用init_mem函数实现。

> 获取上面的结构体数组
>
> 检查内存大小，内存不能太小

# init_mem函数

```C++
\cosmos-master\lesson12\Cosmos\initldr\ldrkrl\chkcpmm.c

#define ETYBAK_ADR 0x2000
#define PM32_EIP_OFF (ETYBAK_ADR)
#define PM32_ESP_OFF (ETYBAK_ADR+4)
#define E80MAP_NR (ETYBAK_ADR+64)//保存e820map_t结构数组元素个数的地址
#define E80MAP_ADRADR (ETYBAK_ADR+68) //保存e820map_t结构数组的开始地址
void init_mem(machbstart_t *mbsp)
{
    e820map_t *retemp;
    u32_t retemnr = 0;
    mmap(&retemp, &retemnr);
    if (retemnr == 0)
    {
        kerror("no e820map\n");
    }
    //根据e820map_t结构数据检查内存大小
    if (chk_memsize(retemp, retemnr, 0x100000, 0x8000000) == NULL)
    {
        kerror("Your computer is low on memory, the memory cannot be less than 128MB!");
    }
    mbsp->mb_e820padr = (u64_t)((u32_t)(retemp));//把e820map_t结构数组的首地址传给mbsp->mb_e820padr 
    mbsp->mb_e820nr = (u64_t)retemnr;//把e820map_t结构数组元素个数传给mbsp->mb_e820nr 
    mbsp->mb_e820sz = retemnr * (sizeof(e820map_t));//把e820map_t结构数组大小传给mbsp->mb_e820sz 
    mbsp->mb_memsz = get_memsize(retemp, retemnr);//根据e820map_t结构数据计算内存大小。
    init_acpi(mbsp);
    return;
}
```

问题一：0x2000地址的具体含义是什么？

问题二：mmap函数的作用是什么？

答：这里的mmap函数主要是执行BIOS int 15h中断来获取内存结构的信息。

根据e820map_t结构数据坚持内存大小，如果小于128MB，打印内核报错并退出。

设置machbstart_t内存相关参数

调用init_acpi函数

## mmap函数

地址同上

```c++
void mmap(e820map_t **retemp, u32_t *retemnr)
{
    realadr_call_entry(RLINTNR(0), 0, 0);
    *retemnr = *((u32_t *)(E80MAP_NR));
    *retemp = (e820map_t *)(*((u32_t *)(E80MAP_ADRADR))); 0x2068
    return;
}
```

调用realadr_call_entry(RLINTNR(0), 0, 0)函数，实际执行的是ldrkrl32.asm中的realadr_call_entry。

```shell
realadr_call_entry:
	pushad
	push    ds
	push    es
	push    fs
	push    gs
	call save_eip_jmp
	pop	gs
	pop	fs
	pop	es
	pop	ds
	popad
	ret
save_eip_jmp:
	pop esi
	mov [PM32_EIP_OFF],esi
	mov [PM32_ESP_OFF],esp
	jmp dword far [cpmty_mode]
cpmty_mode:
	dd 0x1000
	dw 0x18
	jmp $
```

会跳转到save_eip_jmp指令，最后在cpmty_mode处，把 0x18：0x1000 [段描述索引：段内的偏移]，装入到 CS：EIP 寄存器中

因为之前执行了write_realintsvefile函数，将数据加载到了REALDRV_PHYADR  0x1000处，同时这里的0x18是段描述符索引，根据实模式切换到保护模式的过程，CPU会根据索引值18，将新的段描述符信息加载到CS段寄存器中。而0x1000代表段内的偏移地址，因此会去访问在此地址上的realintsve.asm文件。

```shell
[bits 16]
_start:
_16_mode:
  mov  bp,0x20 ;0x20是指向GDT中的16位数据段描述符 
  mov  ds, bp
  mov  es, bp
  mov  ss, bp
  mov  ebp, cr0
  and  ebp, 0xfffffffe
  mov  cr0, ebp ；CR0.P=0 关闭保护模式
  jmp  0:real_entry ；刷新CS影子寄存器，真正进入实模式
real_entry:
  mov bp, cs
  mov ds, bp
  mov es, bp
  mov ss, bp ；重新设置实模式下的段寄存器 都是CS中值，即为0 
  mov sp, 08000h ；设置栈
  mov bp,func_table
  add bp,ax
  call [bp] ；调用函数表中的汇编函数，ax是C函数中传递进来的
  cli
  call disable_nmi
  mov  ebp, cr0
  or  ebp, 1
  mov  cr0, ebp ；CR0.P=1 开启保护模式
  jmp dword 0x8 :_32bits_mode
[BITS 32]
_32bits_mode:
  mov bp, 0x10
  mov ds, bp
  mov ss, bp；重新设置保护模式下的段寄存器0x10是32位数据段描述符的索引
  mov esi,[PM32_EIP_OFF]；加载先前保存的EIP
  mov esp,[PM32_ESP_OFF]；加载先前保存的ESP
  jmp esi ；eip=esi 回到了realadr_call_entry函数中

func_table:  ;函数表
  dw _getmmap ；获取内存布局视图的函数
  dw _read ；读取硬盘的函数
    dw _getvbemode ；获取显卡VBE模式 
    dw _getvbeonemodeinfo ；获取显卡VBE模式的数据
    dw _setvbemode ；设置显卡VBE模式
```

流程如下：

1、从_16_mode:标号处进入实模式

2、根据传递进来的函数号（由ax寄存器传入），到函数表中调用对应的函数，函数表为func_table。

3、当前参数为0，则ax寄存器的值为0，也就是调用了func_table的第一个函数_getmmap

## _getmmap函数

```shell
_getmmap:
  push ds
  push es
  push ss
  mov esi,0
  mov dword[E80MAP_NR],esi
  mov dword[E80MAP_ADRADR],E80MAP_ADR ;e820map结构体开始地址
  xor ebx,ebx ebx设为0
  mov edi,E80MAP_ADR edi设为存放输出结果的1MB内的物理内存地址
loop:
  mov eax,0e820h ;获取e820map结构参数，eax必须为0e820h
  mov ecx,20    ;e820map结构大小，输出结果数据项的大小为20字节：8字节内存基地址，8字节内存长度，4字节内存类型
  mov edx,0534d4150h ;获取e820map结构参数必须是这个数据
  int 15h  ;BIOS的15h中断
  jc .1 如果flags寄存器的C位置1，则表示出错
  add edi,20 更新下一次输出结果的地址
  cmp edi,E80MAP_ADR+0x1000 
  jg .1
  inc esi
  cmp ebx,0 如果ebx为0，表示循环迭代结束
  jne loop ;循环获取e820map结构
  jmp .2
.1:
  mov esi,0    ;出错处理，e820map结构数组元素个数为0
.2:
  mov dword[E80MAP_NR],esi ;e820map结构数组元素个数
  pop ss
  pop es
  pop ds
  ret
```

上面代码在迭代中执行中断，每次中断都输出一个20字节大小的数据项，会形成一个该结构体的数组，结构体为e820map_t。

init_mem函数在调用mmap函数后，会得到e820map结构数组，其首地址和数组元素个数由 retemp，retemnr 两个变量分别提供。

## init_acpi函数

```C++
PUBLIC void init_acpi(machbstart_t *mbsp)
{
    mrsdp_t *rdp = NULL;
    rdp = find_acpi_rsdp();
    if (NULL == rdp)
    {
        kerror("Your computer is not support ACPI!!");
    }
    m2mcopy(rdp, &mbsp->mb_mrsdp, (sint_t)((sizeof(mrsdp_t))));
    if (acpi_rsdp_isok(&mbsp->mb_mrsdp) == NULL)
    {
        kerror("Your computer is not support ACPI!!");
    }
    return;
}
```

通过“RSD PTR ”及校验，判断是否支持ACPI功能
不支持则 打印内核错误并退出，具体调用分析后续补上

到这里，init_mem函数执行完了，返回到了bstartparm.c文件中。

继续调用chkcpmm.c中的init_krlinitstack函数。



# 初始化内核栈

该操作系统是用C语言编写，因此需要有栈。

下面给即将运行的内核初始化一个栈，也就是在机器信息结构machbstart_t中，记录栈地址和栈大小，供内核在启动时使用。

```C++
#define IKSTACK_PHYADR (0x90000-0x10)
#define IKSTACK_SIZE 0x1000
//初始化内核栈
void init_krlinitstack(machbstart_t *mbsp)
{
    if (1 > move_krlimg(mbsp, (u64_t)(0x8f000), 0x1001))
    {
        kerror("iks_moveimg err");
    }
    mbsp->mb_krlinitstack = IKSTACK_PHYADR;//栈顶地址
    mbsp->mb_krlitstacksz = IKSTACK_SIZE; //栈大小是4KB
    return;
}
```

问题一：这里的栈顶地址为什么是0x90000-0x10=0x8f000？

其中调用了一个 move_krlimg 函数你要注意，这个我已经帮你写好啦，它主要负责判断一个地址空间是否和内存中存放的内容有冲突。因为我们的内存中已经放置了机器信息结构、内存视图结构数组、二级引导器、内核映像文件，所以在处理内存空间时不能和内存中已经存在的他们冲突，否则就要覆盖他们的数据。0x8f000～（0x8f000+0x1001），正是我们的内核栈空间，我们需要检测它是否和其它空间有冲突。

## move_krlimg函数

该函数在fs.c文件中

```C++
int move_krlimg(machbstart_t *mbsp, u64_t cpyadr, u64_t cpysz)
{

    if (0xffffffff <= (cpyadr + cpysz) || 1 > cpysz)
    {
        return 0;
    }
    void *toadr = (void *)((u32_t)(P4K_ALIGN(cpyadr + cpysz 0x90001))) = 0x1000;
    sint_t tosz = (sint_t)mbsp->mb_imgsz;
    if (0 != adrzone_is_ok(mbsp->mb_imgpadr, mbsp->mb_imgsz, cpyadr, cpysz))
    {
        if (NULL == chk_memsize((e820map_t *)((u32_t)(mbsp->mb_e820padr)), (u32_t)mbsp->mb_e820nr, (u64_t)((u32_t)toadr), (u64_t)tosz))
        {
            return -1;
        }
        m2mcopy((void *)((u32_t)mbsp->mb_imgpadr)源地址, toadr目的地址, tosz大小);
        mbsp->mb_imgpadr = (u64_t)((u32_t)toadr);
        return 1;
    }
    return 2;
}

#define ALIGN(x, a)     (((x) + (a) - 1) & ~((a) - 1))
#define P4K_ALIGN(x) ALIGN(x,0x1000)

e820map_t *chk_memsize(e820map_t *e8p, u32_t enr, u64_t sadr, u64_t size)
{
    u64_t len = sadr + size;
    if (enr == 0 || e8p == NULL)
    {
        return NULL;
    }
    for (u32_t i = 0; i < enr; i++)
    {
        if (e8p[i].type == RAM_USABLE)
        {
            if ((sadr >= e8p[i].saddr) && (len < (e8p[i].saddr + e8p[i].lsize)))
            {
                return &e8p[i];
            }
        }
    }
    return NULL;
}
```

如果栈底地址大于0xffffffff或者大小小于1，则直接返回0，然后调用adrzone_is_ok函数，判断新申请的地址是否可用，如果不可用，则判断申请内存大小是否超出了设备物理大小。

如果超过了大小，则返回-1，打印内核错误并退出。

如果没有超出大小，则调用m2mcopy从mbsp->mb_imgpadr复制到0x1000地址处，并且修正mbsp->mb_imgpadr的值。（没有弄清楚mbsp->mb_imgpadr的值开始是多少？）

# 放置内核文件和字库文件

目的：解决文件放置的问题，主要是放置内核文件和字库文件

1文件路径：fs.c

```C++
void init_krlfile(machbstart_t *mbsp)
{
    u64_t sz = r_file_to_padr(mbsp, IMGKRNL_PHYADR, "Cosmos.bin"); //#define IMGKRNL_PHYADR 0x2000000
    if (0 == sz)
    {
        kerror("r_file_to_padr err");
    }
    mbsp->mb_krlimgpadr = IMGKRNL_PHYADR;
    mbsp->mb_krlsz = sz;
    //mbsp->mb_nextwtpadr始终要保持指向下一段空闲内存的首地址
    mbsp->mb_nextwtpadr = P4K_ALIGN(mbsp->mb_krlimgpadr + mbsp->mb_krlsz);
    mbsp->mb_kalldendpadr = mbsp->mb_krlimgpadr + mbsp->mb_krlsz;
    return;
}
```

```C++
u64_t r_file_to_padr(machbstart_t *mbsp, u32_t f2adr, char_t *fnm)
{
    if (NULL == f2adr || NULL == fnm || NULL == mbsp)
    {
        return 0;
    }
    u32_t fpadr = 0, sz = 0;
    get_file_rpadrandsz(fnm, mbsp, &fpadr, &sz);
    if (0 == fpadr || 0 == sz)
    {
        return 0;
    }
    if (NULL == chk_memsize((e820map_t *)((u32_t)mbsp->mb_e820padr), (u32_t)(mbsp->mb_e820nr), f2adr, sz))
    {
        return 0;
    }
    if (0 != chkadr_is_ok(mbsp, f2adr, sz))
    {
        return 0;
    }
    m2mcopy((void *)fpadr, (void *)f2adr, (sint_t)sz);
    return sz;
}
```

上面r_file_to_padr函数的作用：在映像中查找相应的文件，并复制到对应的地址（0x2000000），并返回文件的大小，这里查找的是Cosmos.bin。

之后，更新机器信息结构中的数据。

```C++
void init_defutfont(machbstart_t *mbsp)
{
    u64_t sz = 0;
    //获取下一段空闲内存空间的首地址
    u32_t dfadr = (u32_t)mbsp->mb_nextwtpadr;
    //在映像中查找相应的文件，并复制到对应的地址，并返回文件的大小，这里是查找font.fnt文件
    sz = r_file_to_padr(mbsp, dfadr, "font.fnt");
    if (0 == sz)
    {
        kerror("r_file_to_padr err");
    }
    //放置完成后更新机器信息结构中的数据
    mbsp->mb_bfontpadr = (u64_t)(dfadr);
    mbsp->mb_bfontsz = sz;
    //更新机器信息结构中下一段空闲内存的首地址
    mbsp->mb_nextwtpadr = P4K_ALIGN((u32_t)(dfadr) + sz);
    mbsp->mb_kalldendpadr = mbsp->mb_bfontpadr + mbsp->mb_bfontsz;
    return;
}
```

# init_meme820函数

下一步，返回bstartparm.c文件中，代用chkcpmm.c文件的init_meme820函数。

```c++
void init_meme820(machbstart_t *mbsp)
{
    //这里的mbsp中的属性值都是在init_mem函数中赋值的，e820map_t结构数组的首地址0x2068，个数等
    e820map_t *semp = (e820map_t *)((u32_t)(mbsp->mb_e820padr));
    u64_t senr = mbsp->mb_e820nr;
    e820map_t *demp = (e820map_t *)((u32_t)(mbsp->mb_nextwtpadr));//获取下一段空闲内存空间的首地址
    if (1 > move_krlimg(mbsp, (u64_t)((u32_t)demp), (senr * (sizeof(e820map_t)))))
    {
        kerror("move_krlimg err");
    }

    m2mcopy(semp, demp, (sint_t)(senr * (sizeof(e820map_t))));
    mbsp->mb_e820padr = (u64_t)((u32_t)(demp));
    mbsp->mb_e820sz = senr * (sizeof(e820map_t));
    mbsp->mb_nextwtpadr = P4K_ALIGN((u32_t)(demp) + (u32_t)(senr * (sizeof(e820map_t))));
    mbsp->mb_kalldendpadr = mbsp->mb_e820padr + mbsp->mb_e820sz;
    return;
}
```

将init_mem() 中获取到的内存信息转存到字体文件之后，也就是上面代码中的demp获取到的字体文件之后的下一段空闲内存空间的首地址0x2086到字体文件的下一段空闲内存空间的首地址之后。

看后面的解释，有一个是说在实模式下能用的地址空间有限，只能访问1MB的内存范围，只能访问低地址，如果放在低位地址空间的话，实模式下内存容易被占满，那么我们的中断就无法在实模式下使用了。

# 建立MMU页表数据

在二级引导器中建立MMU页表数据，目的是要在内核加载运行之初开启长模式时，MMU需要的页表数据已经准备好。

内核虚拟地址空间从 0xffff800000000000 开始，所以我们这个虚拟地址映射到从物理地址 0 开始，大小都是 0x400000000 即 16GB，也就是说我们要虚拟地址空间：0xffff800000000000～0xffff800400000000 映射到物理地址空间 0～0x400000000。

使用长模式下的2MB分页方式，如下所示：

```C++

#define KINITPAGE_PHYADR 0x1000000
void init_bstartpages(machbstart_t *mbsp)
{
    //顶级页目录
    u64_t *p = (u64_t *)(KINITPAGE_PHYADR);//16MB地址处,#define KINITPAGE_PHYADR 0x1000000
    //页目录指针,开始于0x1001000，共16项，其中每一项指向一个页目录,
    u64_t *pdpte = (u64_t *)(KINITPAGE_PHYADR + 0x1000);
    //页目录,开始于0x1002000,每个页目录指向512个物理页，每页2MB，0x200000
    u64_t *pde = (u64_t *)(KINITPAGE_PHYADR + 0x2000);
    //物理地址从0开始
    u64_t adr = 0;
    if (1 > move_krlimg(mbsp, (u64_t)(KINITPAGE_PHYADR), (0x1000 * 16 + 0x2000)))
    {
        kerror("move_krlimg err");
    }
    //将顶级页目录、页目录指针的空间清0
    for (uint_t mi = 0; mi < PGENTY_SIZE（512）; mi++)
    {
        p[mi] = 0;
        pdpte[mi] = 0;
    }
    //映射
    for (uint_t pdei = 0; pdei < 16; pdei++)
    {
        pdpte[pdei] = (u64_t)((u32_t)pde | KPDPTE_RW | KPDPTE_P);
        for (uint_t pdeii = 0; pdeii < PGENTY_SIZE（512）; pdeii++)
        {//大页KPDE_PS 2MB，可读写KPDE_RW，存在KPDE_P
            pde[pdeii] = 0 | adr | KPDE_PS | KPDE_RW | KPDE_P;
            adr += 0x200000;
        }
        pde = (u64_t *)((u32_t)pde + 0x1000);
    }
    //让顶级页目录中第0项和第((KRNL_VIRTUAL_ADDRESS_START) >> KPML4_SHIFT) & 0x1ff项，指向同一个页目录指针页  
    p[((KRNL_VIRTUAL_ADDRESS_START) >> KPML4_SHIFT) & 0x1ff] = (u64_t)((u32_t)pdpte | KPML4_RW | KPML4_P);
    p[0] = (u64_t)((u32_t)pdpte | KPML4_RW | KPML4_P);
    //把页表首地址保存在机器信息结构中
    mbsp->mb_pml4padr = (u64_t)(KINITPAGE_PHYADR);
    mbsp->mb_subpageslen = (u64_t)(0x1000 * 16 + 0x2000);
    mbsp->mb_kpmapphymemsz = (u64_t)(0x400000000);
    return;
}
```

这个函数的代码写得非常简单，映射的核心逻辑由两重循环控制，外层循环控制页目录指针顶，只有 16 项，其中每一项都指向一个页目录，每个页目录中有 512 个物理页地址。物理地址每次增加 2MB，这是由 26～30 行的内层循环控制，每执行一次外层循环就要执行 512 次内层循环。最后，顶级页目录中第 0 项和第 ((KRNL_VIRTUAL_ADDRESS_START) >> KPML4_SHIFT) & 0x1ff 项，指向同一个页目录指针页，这样的话就能让虚拟地址：0xffff800000000000～0xffff800400000000 和虚拟地址：0～0x400000000，访问到同一个物理地址空间 0～0x400000000，这样做是有目的，内核在启动初期，虚拟地址和物理地址要保持相同。

\#define KRNL_VIRTUAL_ADDRESS_START 0xffff800000000000

\#define KPML4_SHIFT 39

因此((KRNL_VIRTUAL_ADDRESS_START) >> KPML4_SHIFT) & 0x1ff为100000000即0x100，256，但是还是没有太懂。按照第6章中的长模式下的64位虚拟地址如下：

![img](https://static001.geekbang.org/resource/image/ec/c9/ecdea93c2544cf9c1d84461b602b03c9.jpg?wh=4605*1845)

可以看到顶级目录索引是8位，也就是0-255，那么将256项置为和0项为同一个物理地址，也就访问到了同一个物理空间。