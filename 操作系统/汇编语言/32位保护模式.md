参考书籍：《x86汇编语言-从实模式到保护模式》



# 32位微处理器架构

处理器架构师一整套的硬件结构，以及与之相适应的工作状态。

8086有20根地址线，可以寻址1MB内存，但是，内部寄存器是16位的，无法在程序中访问整个1MB内存，因此，8086是第一款支持内存分段模型的处理器，8086处理器只有实模式。

32位处理器有32根地址线，数据线的数量是32或64根，可以访问4GB的内存，每次可以读写连续的4字节或8字节。

## 寄存器扩展

16位处理器中，有8个通用寄存器AX、BX、CX、DX、SI、DI、BP、SP，其中前4个可以拆分成两个独立的8位寄存器来使用，即AH、AL、BH、BL、CH、CL、DH、DL。

32位处理器在16位的基础上，扩展了8个通用寄存器的长度，如下：

![image-20220806160952546](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20220806160952546.png)

扩展后的寄存器的名字：EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP。

可以在程序中使用这些寄存器，即使是在实模式下。

```shell
mov eax,0xf0000005
mov ecx,eax
add edx,ecx
```

指令的源操作数和目的操作数必须有相同的长度。

下面的命令是不允许的，编译时报错

```
mov eax,cx  32,16
```

32位通用寄存器的高16位不可独立使用，低16位保持同16位处理器的兼容性。

```
mov ah,0x02
mov al,0x23
add ax,si
```

在32位模式下，为了生成32位物理地址，处理器需要使用32位的指令指针寄存器，因此，32位处理器扩展了IP，为EIP。

![image-20220806161934756](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20220806161934756.png)

对IP和EIP的修改通常是用某些指令隐式进行的，这些指令包括JMP、CALL、RET、IRET等。

在16位处理器中， 标志寄存器FLAGS是16位的，在32位处理器中，扩展到32位，低16位和原先保持一致。

![image-20220806162508807](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20220806162508807.png)

在32位模式下，处理器要求在加载程序时，先定义该程序所拥有的段，然后允许使用这些段。定义段时，除了基地址之外，还附加了段界限、特权级别、类型等属性。

在32位模式下，传统的段寄存器，如CS、SS、DS、ES，保存的不再是16位段基地址，而是段的选择子——用于选择要访问的段（段选择器）。

![image-20220806163102488](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20220806163102488.png)

每个段寄存器还包括一个 64 位的不可见部分，称为描述符高速缓存器，里面有段的基地址和各种访问属性。这部分内容程序不可访问，由处理器自动使用。

# 进入保护模式

用户程序只能访问属于自己的数据，即使是转移，也只能在自己的代码段之间进行。

在多用户、多任务时代，内存中会有多个用户（应用）程序在同时运行。为了使它们彼此隔离，防止因某个程序的编写错误或者崩溃而影响到操作系统和其他用户程序，使用保护模式是非常有必
要的。

## 全局描述符表GDT

为了让程序在内存中能自由浮动而又不影响它的正常执行，处理器将内存划分成逻辑上的段，并在指令中使用段内偏移地址。在保护模式下，对内存的访问仍然使用段地址和偏移地址，但是，<font color=red>在每个段能够访问之前，必须先进行登记。</font>

和一个段有关的信息需要8个字节来描述，称为段描述符，每个段都需要一个段描述符。为了存放这些描述符，在内存中开辟出一段空间，所有的描述符都放在一起集中存放，构成一个描述符表。

最主要的描述符表是全局描述符表GDT。所谓全局，意味着该表是
为整个软硬件系统服务的。在进入保护模式前，必须要定义全局描述符表。

为了跟踪全局描述符表，处理器内部有一个 48 位的寄存器，称为<font color=red>全局描述符表寄存器（GDTR）</font>。该寄存器分为两部分，分别是 32 位的线性地址和 16 位的边界。32 位的处理器具有 32 根地址线，可以访问的地址范围是 0x00000000 到 0xFFFFFFFF，共4GB 内存。所以，GDTR 的 32 位线性基地址部分保存的是全局描述符表在内存中的起始线性地址，16 位边界部分保存的是全局描述符表的边界（界限），其在数值上等于表的大小（总字节数）减一。

![image-20220806163923189](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20220806163923189.png)

因为 GDT 的界限是 16 位的，所以，该表最大是 2 16 字节，也就是 65536 字节（64KB）。又因为一个描述符占 8 字节，故最多可以定义 8192 个描述符。实际上，不一定非得这么多，到底有多少，视需要而定，但最多不能超过 8192 个。
理论上，全局描述符表可以位于内存中的任何地方。但是，如图 11-2 所示，由于在进入保护模式之后，处理器立即要按新的内存访问模式工作，所以，必须在进入保护模式之前定义 GDT。但是，由于在实模式下只能访问 1MB 的内存，故 <font color=red>GDT 通常都定义在 1MB 以下的内存范围中。</font>当然，允许在进入保护模式之后换个位置重新定义 GDT。

![image-20220806174615646](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20220806174615646.png)

### 存储器的段描述符

在程序开始后，需要定义主引导扇区代码所使用的数据段、代码段、堆栈段。在保护模式下，内存的访问机制必须通过描述符来进行，因此这些段必须重新的GDT中定义。

先是确定 GDT 的起始线性地址。声明了标号 gdt_base 并初始化了一个双字0x00007e00，我们决定从这个地方开始创建全局描述符表（GDT）。这是有意的，如图 11-3 所示，在实模式下，主引导程序的加载位置是 0x0000:0x7c00，也就是物理地址 0x07c00。因为现在的地址是 32 位的，所以它现在对应着物理地址 0x00007c00。主引导扇区程序共 512（0x200）字节，所以，我们决定把 GDT 设在主引导程序之后，也就是物理地址 0x00007e00 处。因为 GDT 最大可以为 64KB，所以，理论上，它的尺寸可以扩展到物理地址0x00017dff 处。

![image-20220806205630563](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20220806205630563.png)

因为堆栈指针寄存器SP被初始化为0x7c00，和CS一样，堆栈段寄存器SS被初始化为0x0000，而且堆栈是向下扩展的，所以，从0x00007c00往下的区域是实际上可用的堆栈区域。

在保护模式下，在访问内存之前，必须要先在GDT内定义要访问的内存段。主要是因为在整个计算机系统中，会有很多程序共同在OS上运行，所以，描述符不是由用户程序自己建立的，而是在加时，由操作系统根据你的程序结构而建立的，而用户程序通常是无法立和修改 GDT 的，也就只能老老实实地在自己的地盘上工作。

一旦确定了GDT在内存中的起始位置，下一步就是确定要访问的段，并在GDT中为这些段创建各自的描述符。

![image-20220806210006507](C:\Users\kd\AppData\Roaming\Typora\typora-user-images\image-20220806210006507.png)

每个描述符在GDT中占8字节，也就是64位，如上图中的，下面是低32位，上面是高32位。

描述符中指定了32位的段起始地址，20位的段边界。在32位保护模式下，段地址是32位线性地址，如果未开启分页功能，该线性地址就是物理地址，这是和实模式不一样的地方。

20位的段界限用来限制段的扩展范围。因为访问内存的方法是用段基地址加上偏移量，所以，对于向上扩展的段，如代码段和数据段来说，偏移量是从 0 开始递增，段界限决定了偏移量的最大值；对于向下扩展的段，如堆栈段来说，段界限决定了偏移量的最小值。

G位是粒度位，用于解释段界限的含义。当为0时，段界限以字节为单位，范围从1字节到1MB。如果为1，段界限以4KB为单位，扩展范围从4KB到4GB。

S位用于指定描述符的类型。为0时，表示是一个系统段，为1时，表示是一个代码段或数据段。

DPL表示描述符的特权级。这两位用于指定段的特权级。共有 4 种处理器支持的特权级别，分别是 0、1、2、3，其中 0 是最高特权级别，3 是最低特权级别。刚进入保护模式时执行的代码具有最高特权级 0（可以看成是从处理器那里继承来的），这些代码通常都是操作系统代码，因此它的特权级别最高。每当操作系统加载一个用户程序时，它通常都会指定一个稍低的特权级，比如 3 特权级。不同特权级别的程序是互相隔离的，其互访是严格限制的，而且有些处理器指令（特权指令）只能由 0 特权级的程序来执行，为的就是安全。

其余的后面再添加。

## 安装存储器的段描述符并加载GDTR

注意这些都是在实模式下进行的。

### 创建GDT表