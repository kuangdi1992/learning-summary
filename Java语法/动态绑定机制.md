# 动态绑定机制

## 注意事项

1、当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定。

2、当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用

## 示例

```java
package com.company.poly_;

public class DynamicBinding {
    public static void main(String[] args) {

        A a = new B();
        System.out.println(a.sum());
        System.out.println(a.sum1());

    }
}

class A {
    public int i = 10;

    public int sum(){
        return getI() + 10;
    }

    public int sum1(){
        return i + 10;
    }

    public int getI(){
        return i;
    }
}

class B extends A {
    public int i = 20;

//    public int sum(){
//        return i + 20;
//    }
//
//    public int sum1(){
//        return i + 10;
//    }

    public int getI(){
        return i;
    }
}
```

- 当注释掉B子类的sum方法时，执行main函数，因为a的运行类型是B，所以先寻找子类的sum方法，发现没有，于是寻址父类的sum方法，其中有return getI() + 10；
- 根据动态绑定机制第一条，调用对象方法时，方法会和对象的运行类型绑定，所以getI()方法会执行B子类中的getI方法，返回i=20，然后+10，结果为30.
- 当注释掉B子类的sum1方法时，执行main函数，因为a的运行类型是B，所以先寻找子类的sum1方法，发现没有，于是寻址父类的sum1方法.
- 根据动态绑定机制第二条，调用对象属性时，没有动态绑定机制，哪里声明，哪里使用，所以父类A中sum1方法中的i，是父类A中的i，值为10，因此sum1返回结果20。

结果：

```
30
20
```

